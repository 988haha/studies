树形递归技巧
===
<!--START_SECTION:badge-->

![last modify](https://img.shields.io/static/v1?label=last%20modify&message=2022-10-17%2001%3A31%3A10&color=yellowgreen&style=flat-square)

<!--END_SECTION:badge-->
<!--info
top: false
hidden: false
-->

<!-- TOC -->
- [前言](#前言)
- [自底向上的递归技巧](#自底向上的递归技巧)
- [典型问题](#典型问题)
    - [示例 1: 二叉树的高度](#示例-1-二叉树的高度)
    - [示例 2: 判断是否为平衡二叉树/搜索二叉树/完全二叉树](#示例-2-判断是否为平衡二叉树搜索二叉树完全二叉树)
    - [示例 3: 二叉树中的最大路径和](#示例-3-二叉树中的最大路径和)
    - [示例 4: 打家劫舍 III](#示例-4-打家劫舍-iii)
- [更多相关问题](#更多相关问题)
- [参考资料](#参考资料)
<!-- TOC -->

## 前言
- 二叉树的三种遍历方式 (前序, 中序, 后序) 代表了三种典型的递归场景;
    ```python
    def dfs(node):
        if node is None: return
        
        ...  # 前序
        dfs(node.left)
        ...  # 中序
        dfs(node.right)
        ...  # 后序
    ```
- 这三种的主要区别在于遍历到该节点时, 已知的信息不同, 除了已经遍历过的节点外: 
    - 前序遍历时, 只有当前节点的信息;
    - 中序遍历时, 只有左子树的信息;
    - 后序遍历时, 可以同时获得左右子树的信息;
- 因此, 面对二叉树问题时, 判断所需的信息是关键;
- 问题分布:
    - 典型的中序问题比较少见;
    - 纯前序遍历问题可以看作是一种特殊的线性遍历;
    - 大部分有难度, 且使用到二叉树性质的问题都集中在后序遍历; 一些更难的问题则需要先前序遍历进行预处理, 再后序遍历进行递推;
- 本篇主要讨论二叉树后序遍历的技巧, 这个方法可以用于所有需要**自底向上进行递归**的问题;

## 自底向上的递归技巧
> 基于二叉树的后序遍历, 也作**树形 dp**;

- 记 `dfs(x)` 模板如下:
    ```python
    from dataclasses import dataclass

    @dataclass
    class Info:
        ...  # default

    def dfs(x) -> Info:
        if x is None: return Info()

        l_info = dfs(x.left)
        r_info = dfs(x.right)
        x_info = get_from(l_info, r_info)
        return x_info
    ```
- 考虑计算出当前节点的答案需要从左右子树获得哪些信息, 并**假设已知**, 记 `l_info` 和 `r_info`; 
- 利用 `l_info` 和 `r_info` 构造出当前节点应该返回的信息 `x_info`;
- 注意空树返回的信息, 即 `Info` 的默认值;
- 为了可读性, 推荐使用**结构体** (python 中推荐使用 `dataclass`) 来保存需要的信息; 
- 进一步的, 最终生成的 `x_info` 不一定都会与 `x` 有关, 此时需要分**与 x 有关的答案**和**与 x 无关的答案**进行讨论, 并取其中的最优解 (详见示例 3 和 4);


## 典型问题

### 示例 1: 二叉树的高度
> [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

- 二叉树 `x` 的高度等于左右子树高度中的较大值 `+1`;

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        
        def dfs(x):
            if x is None: return 0

            l, r = dfs(x.left), dfs(x.right)
            return max(l, r) + 1
        
        return dfs(root)
```
> 本题比较简单, 故简化了模板;

### 示例 2: 判断是否为平衡二叉树/搜索二叉树/完全二叉树
> [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/)  
> [110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode-cn.com/problems/balanced-binary-tree/)  
> [958. 二叉树的完全性检验 - 力扣（LeetCode）](https://leetcode.cn/problems/check-completeness-of-a-binary-tree/)  

- 搜索二叉树: 对**每个节点**, 其值大于左子树的**最大值**，小于右子树的**最小值**;
- 平衡二叉树: 对**每个节点**, 其左右子树的**高度**差 `<= 1`;
- 完全二叉树, 这里给出两种判断条件:
    - 条件1:
        - 左右子树都是满二叉树，且高度相同, 即本身是满二叉树；
        - 左右子树都是满二叉树，且左子树的高度+1；
        - 左子树是满二叉树，右子树是完全二叉树，且高度相同；
        - 左子树是完全二叉树，右子树是满二叉树，且左子树的高度+1；
            > **满二叉树**: 左右子树的高度相同, 且都是满二叉树;
    - 条件2, 该方法需要前序遍历进行预处理 (可以跟后序写在一起) 这里略:
        - 记根节点 `id` 为 `1`；若父节点的 `id` 为 `i`，则其左右子节点分别为 `2*i` 和 `2*i+1`；
        - 如果是完全二叉树则有 `max_id == n`，其中 `n` 为总节点数；
- 以下为合并实现

```python
class Solution:
    def isXxxTree(self, root: TreeNode) -> bool:

        from dataclasses import dataclass

        @dataclass
        class Info:
            height: int = 0               # 树的高度
            max_val: int = float('-inf')  # 最大值
            min_val: int = float('inf')   # 最小值
            is_balance: bool = True       # 是否平衡二叉树
            is_search: bool = True        # 是否搜索二叉树
            is_full: bool = True          # 是否满二叉树
            is_complete: bool = True      # 是否完全二叉树
        
        def dfs(x):
            if not x: return Info()

            l, r = dfs(x.left), dfs(x.right)

            # 利用左右子树的info 构建当前节点的info
            height = max(l.height, r.height) + 1
            max_val = max(x.val, l.max_val, r.max_val)
            min_val = min(x.val, l.min_val, r.min_val)
            is_balance = l.is_balance and r.is_balance and abs(l.height - r.height) <= 1
            is_search = l.is_search and r.is_search and x.val > l.max_val and x.val < r.min_val
            is_full = l.is_full and r.is_full and l.height == r.height
            is_complete = is_full \
                or l.is_full and r.is_full and l.height - 1 == r.height \
                or l.is_full and r.is_complete and l.height == r.height \
                or l.is_complete and r.is_full and l.height - 1 == r.height
            
            return Info(height, max_val, min_val, is_balance, is_search, is_full, is_complete)
        
        return dfs(root).xxx  # 根据具体问题确定返回值
```

### 示例 3: 二叉树中的最大路径和
> [124. 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

- 根据最大路径和是否经过 `x` 节点分两种情况;
    - 如果不经过 `x` 节点, 那么 `x` 中的最大路径和等于左右子树中最大路径和中的较大值;
    - 如果经过 `x` 节点, 那么 `x` 的最大路径和等于左右子树能提供的最大路径之和, 再加上当前节点的值;
    - 取两者中的较大值;
- 综上, 需要记录的信息包括, 当前节点能提供的最大路径, 当前的最大路径;
    - 所谓 "当前节点能提供的最大路径", 即从该节点向下无回溯遍历能得到的最大值; 假设每个节点能提供的路径都是 1, 那么这个最大路径就是树的高度;
    - 因为节点值存在负数, 这是一个容易出错的点 (详见代码);
- 从本题可以看到, 模板并不能解决问题, 只是减少了问题以外的思考, 即如何将思路转换为代码.

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:

        from dataclasses import dataclass

        @dataclass
        class Info:
            # 易错点: 因为存在负值, 所以初始化为负无穷 (最小值为 -1000)
            h: int = -1001  # 当前节点能提供的最大路径
            s: int = -1001  # 当前节点下的最大路径
        
        def dfs(x):
            if not x: return Info()

            l, r = dfs(x.left), dfs(x.right)
            # 利用左右子树的信息, 计算当前节点的信息
            h = x.val + max(l.h, r.h, 0)  # 易错点: 如果左右子树能提供的最大路径是一个负数, 则应该直接舍去
            s_through_x = x.val + max(l.h, 0) + max(r.h, 0)  # 易错点: 同上
            # 因为 h 和 s_through_x 都和当前节点有关, 所以必须包含当前节点
            s = max(l.s, r.s, s_through_x)  # 但是最终结果不一定包含 x, 需要取最优解
            return Info(h, s)
        
        return dfs(root).s
```

### 示例 4: 打家劫舍 III
> [337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode-cn.com/problems/house-robber-iii/)

- 树形 dp，就是否抢劫当前节点分两种情况讨论;

```python
class Solution:
    def rob(self, root: TreeNode) -> int:

        from functools import lru_cache

        @lru_cache
        def dfs(x):
            # 空节点, 不抢
            if not x: return 0
            # 叶节点, 必抢
            if not x.left and not x.right: return x.val

            # 不抢当前节点, 抢左右子节点
            r1 = dfs(x.left) + dfs(x.right)
            # 抢当前节点, 跳过左右子节点, 抢子节点的子节点
            r2 = x.val
            if x.left:  # 非空判断
                r2 += dfs(x.left.left) + dfs(x.left.right)
            if x.right:  # 非空判断
                r2 += dfs(x.right.left) + dfs(x.right.right)
            
            return max(r1, r2)
        
        return dfs(root)
```


## 更多相关问题
> algorithms/[树形递归](../../../../algorithms/README.md#树形递归)


## 参考资料
- [动态规划——树形DP_浅梦曾倾 - CSDN](https://blog.csdn.net/qq_45949914/article/details/108905959)
- [从五道题来看树形DP_数学家是我理想 - CSDN](https://blog.csdn.net/qq_37236745/article/details/83653622)
- [[视频] 二叉树的递归套路_左程云算法教程 (p47) - B站](https://www.bilibili.com/video/BV1NU4y1M7rF?p=47)
- [[文字] 树型递归思想_LiJiaLe - CSDN](https://blog.csdn.net/Strive_LiJiaLe/article/details/116332829)
